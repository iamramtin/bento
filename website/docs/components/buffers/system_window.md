---
title: system_window
type: buffer
status: experimental
categories: ["Windowing"]
---

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the contents of:
     lib/buffer/system_window.go
-->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::caution EXPERIMENTAL
This component is experimental and therefore subject to change or removal outside of major version releases.
:::
Chops a stream of messages into tumbling or sliding windows of fixed temporal size, following the system clock.

```yaml
# Config fields, showing default values
buffer:
  system_window:
    timestamp_mapping: root = now()
    size: ""
    slide: ""
    offset: ""
    allowed_lateness: ""
```

A window is a grouping of messages that fit within a discrete measure of time. Messages are allocated to a window either by the processing time (the time at which they're ingested) or by the event time, and this is controlled via the [`timestamp_mapping` field](#timestamp_mapping)`.

In tumbling mode (default) the beginning of a window immediately follows the end of a prior window. When the buffer is initialized the first window to be created and populated is aligned against the zeroth minute of the zeroth hour of the day by default, and may therefore be open for a shorter period than the specified size.

A window is flushed only once the system clock surpasses its scheduled end. If an [`allowed_lateness`](#allowed_lateness) is specified then the window will not be flushed until the scheduled end plus that length of time. When the service is shut down any partial windows will be dropped.

## Sliding Windows

Sliding windows begin from an offset of the prior windows' beginning rather than its end, and therefore messages may belong to multiple windows. In order to produce sliding windows specify a [`slide` duration](#slide).

## Back Pressure

If back pressure is applied to this buffer either due to output services being unavailable or resources being saturated, windows older than the current and last according to the system clock will be dropped in order to prevent unbounded resource usage. This means you should ensure that under the worst case scenario you have enough system memory to store two windows' worth of data at a given time (plus extra for redundancy and other services).

If messages could potentially arrive with event timestamps in the future (according to the system clock) then you should also factor in these extra messages in memory usage estimates.

## Delivery Guarantees

Using a buffer weakens the delivery guarantees of the pipeline by decoupling the acknowledgement of inputs from components downstream of the buffer. Therefore, in the event of server crashes or other rare faults there is no guarantee that messages are not lost when using this buffer. If you instead require strict delivery guarantees for your data consider instead using an [input broker with a batching policy](/docs/components/inputs/broker), with the `batching.period` field set to the window period.


## Fields

### `timestamp_mapping`

A [Bloblang mapping](/docs/guides/bloblang/about) applied to each message during ingestion that provides the timestamp to use for allocating it a window. By default the function `now()` is used in order to generate a fresh timestamp at the time of ingestion (the processing time), whereas this mapping can instead extract a timestamp from the message itself (the event time).

The timestamp value assigned to `root` must either be a numerical unix time in seconds (with up to nanosecond precision via decimals), or a string in ISO 8601 format. If the mapping fails or provides an invalid result the message will be dropped (with logging to describe the problem).


Type: `string`  
Default: `"root = now()"`  

```yaml
# Examples

timestamp_mapping: root = this.created_at

timestamp_mapping: root = meta("kafka_timestamp_unix").number()
```

### `size`

A duration string describing the size of each window. By default windows are aligned to the zeroth minute and zeroth hour on the UTC clock, meaning windows of 1 hour duration will match the turn of each hour in the day, this can be adjusted with the `offset` field.


Type: `string`  

```yaml
# Examples

size: 30s

size: 10m
```

### `slide`

An optional duration string describing by how much time the beginning of each window should be offset from the beginning of the previous, and therefore creates sliding windows instead of tumbling. When specified this duration must be smaller than the `size` of the window.


Type: `string`  
Default: `""`  

```yaml
# Examples

slide: 30s

slide: 10m
```

### `offset`

An optional duration string to offset the beginning of each window by, otherwise they are aligned to the zeroth minute and zeroth hour on the UTC clock.


Type: `string`  
Default: `""`  

```yaml
# Examples

offset: -6h

offset: 30m
```

### `allowed_lateness`

An optional duration string describing the length of time to wait after a window has ended before flushing it, allowing late arrivals to be included. Since this windowing buffer uses the system clock an allowed lateness can improve the matching of messages when using event time.


Type: `string`  
Default: `""`  

```yaml
# Examples

allowed_lateness: 10s

allowed_lateness: 1m
```


