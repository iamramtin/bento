// Copyright (c) 2018 Ashley Jeffs
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"sort"
	"strings"

	"github.com/Jeffail/benthos/lib/api"
	"github.com/Jeffail/benthos/lib/buffer"
	"github.com/Jeffail/benthos/lib/input"
	"github.com/Jeffail/benthos/lib/log"
	"github.com/Jeffail/benthos/lib/metrics"
	"github.com/Jeffail/benthos/lib/output"
	"github.com/Jeffail/benthos/lib/pipeline"
	"github.com/Jeffail/benthos/lib/processor"
	yaml "gopkg.in/yaml.v2"
)

//------------------------------------------------------------------------------

// Config is the benthos configuration struct.
type Config struct {
	HTTP     api.Config      `json:"http" yaml:"http"`
	Input    input.Config    `json:"input" yaml:"input"`
	Buffer   buffer.Config   `json:"buffer" yaml:"buffer"`
	Pipeline pipeline.Config `json:"pipeline" yaml:"pipeline"`
	Output   output.Config   `json:"output" yaml:"output"`
}

// NewConfig returns a new configuration with default values.
func NewConfig() Config {
	return Config{
		HTTP:     api.NewConfig(),
		Input:    input.NewConfig(),
		Buffer:   buffer.NewConfig(),
		Pipeline: pipeline.NewConfig(),
		Output:   output.NewConfig(),
	}
}

// Sanitised returns a sanitised copy of the Benthos configuration, meaning
// fields of no consequence (unused inputs, outputs, processors etc) are
// excluded.
func (c Config) Sanitised(sanitBuffer, sanitPipe bool) (interface{}, error) {
	inConf, err := input.SanitiseConfig(c.Input)
	if err != nil {
		return nil, err
	}

	var bufConf interface{}
	if sanitBuffer {
		bufConf, err = buffer.SanitiseConfig(c.Buffer)
		if err != nil {
			return nil, err
		}
	} else {
		bufConf = c.Buffer
	}

	var pipeConf interface{}
	if sanitPipe {
		pipeConf, err = pipeline.SanitiseConfig(c.Pipeline)
		if err != nil {
			return nil, err
		}
	} else {
		pipeConf = c.Pipeline
	}

	var outConf interface{}
	outConf, err = output.SanitiseConfig(c.Output)
	if err != nil {
		return nil, err
	}

	return struct {
		HTTP     interface{} `json:"http" yaml:"http"`
		Input    interface{} `json:"input" yaml:"input"`
		Buffer   interface{} `json:"buffer" yaml:"buffer"`
		Pipeline interface{} `json:"pipeline" yaml:"pipeline"`
		Output   interface{} `json:"output" yaml:"output"`
	}{
		HTTP:     c.HTTP,
		Input:    inConf,
		Buffer:   bufConf,
		Pipeline: pipeConf,
		Output:   outConf,
	}, nil
}

//------------------------------------------------------------------------------

func create(t, path string, resBytes []byte) {
	if err := ioutil.WriteFile(path, resBytes, 0644); err != nil {
		panic(err)
	}
	fmt.Printf("Generated '%v' at: %v\n", t, path)
}

func createYAML(t, path string, sanit interface{}) {
	resBytes := []byte("# This file was auto generated by benthos_config_gen.\n")

	cBytes, err := yaml.Marshal(sanit)
	if err != nil {
		panic(err)
	}
	resBytes = append(resBytes, cBytes...)

	if err = ioutil.WriteFile(path, resBytes, 0644); err != nil {
		panic(err)
	}
	fmt.Printf("Generated '%v' config at: %v\n", t, path)
}

func createJSON(t, path string, sanit interface{}) {
	resBytes, err := json.MarshalIndent(sanit, "", "	")
	if err != nil {
		panic(err)
	}

	if err = ioutil.WriteFile(path, resBytes, 0644); err != nil {
		panic(err)
	}
	fmt.Printf("Generated '%v' config at: %v\n", t, path)
}

func envify(rootPath string, conf interface{}, paths map[string]interface{}) (newConf interface{}) {
	genBytes, err := json.Marshal(conf)
	if err != nil {
		panic(err)
	}

	dec := json.NewDecoder(bytes.NewReader(genBytes))
	dec.UseNumber()

	var genConf interface{}
	if err = dec.Decode(&genConf); err != nil {
		panic(err)
	}

	blacklist := []string{
		"READ_UNTIL",
		"CONDITIONAL",
		"FILTER",
		"DEDUPE",
		"INPUT_BROKER_INPUTS_BROKER",
		"OUTPUT_BROKER_OUTPUTS_BROKER",
	}
	aliases := map[string]string{
		"INPUT_BROKER_INPUTS":   "INPUT",
		"INPUT_BROKER_COPIES":   "INPUTS",
		"PIPELINE_PROCESSORS":   "PROCESSOR",
		"PIPELINE_THREADS":      "PROCESSOR_THREADS",
		"OUTPUT_BROKER_OUTPUTS": "OUTPUT",
		"OUTPUT_BROKER_PATTERN": "OUTPUTS_PATTERN",
		"OUTPUT_BROKER_COPIES":  "OUTPUTS",
	}

	var traverse func(path string, to *interface{}, from interface{})
	traverse = func(path string, to *interface{}, from interface{}) {
		if obj, isObj := from.(map[string]interface{}); isObj {
			newMap := map[string]interface{}{}
		keyIter:
			for k, v := range obj {
				newPath := path + "_" + strings.ToUpper(k)
				for _, b := range blacklist {
					if strings.Contains(newPath, b) {
						// Skip values that hit our blacklist.
						continue keyIter
					}
				}
				var newVal interface{}
				traverse(newPath, &newVal, v)
				if newVal != nil {
					newMap[k] = newVal
				}
			}
			if len(newMap) > 0 {
				*to = newMap
			}
			return
		} else if len(path) == 0 {
			panic("Environment values at path root")
		}
		if array, isArray := from.([]interface{}); isArray {
			var newArray []interface{}
			for _, ele := range array {
				var newVal interface{}
				traverse(path, &newVal, ele)
				if newVal != nil {
					newArray = append(newArray, newVal)
				}
			}
			if len(newArray) > 0 {
				*to = newArray
			}
			return
		}
		for alias := range aliases {
			if strings.Contains(path, alias) {
				path = strings.Replace(path, alias, aliases[alias], 1)
			}
		}
		var valStr string
		switch t := from.(type) {
		case string:
			valStr = t
		case bool:
			if t {
				valStr = "true"
			} else {
				valStr = "false"
			}
		case json.Number:
			valStr = t.String()
		}
		paths[path] = from
		if len(valStr) > 0 {
			*to = "${" + path + ":" + valStr + "}"
		} else {
			*to = "${" + path + "}"
		}
	}

	traverse(rootPath, &newConf, genConf)
	return
}

func formatEnvVars(vars map[string]interface{}) []byte {
	categories := []string{
		"HTTP", "INPUT", "BUFFER", "PROCESSOR", "OUTPUT", "LOGGER", "METRICS",
	}

	for _, cat := range categories {
		sortedVars := []string{}
		for k := range vars {
			if strings.HasPrefix(k, cat) {
				sortedVars = append(sortedVars, k)
			}
		}
		sort.Strings(sortedVars)
	}

	return []byte{} // TODO
}

func createEnvConf(configsDir string) {
	inConf := input.NewConfig()
	inConf.Type = "dynamic"

	inBrokerConf := struct {
		Copies int           `json:"copies"`
		Inputs []interface{} `json:"inputs"`
	}{
		Copies: 1,
		Inputs: []interface{}{inConf},
	}

	procConf := processor.NewConfig()
	procConf.Type = "noop"

	pipeConf := pipeline.NewConfig()
	pipeConf.Processors = append(pipeConf.Processors, procConf)

	outConf := output.NewConfig()
	outConf.Type = "dynamic"

	outBrokerConf := struct {
		Copies  int           `json:"copies"`
		Pattern string        `json:"pattern"`
		Outputs []interface{} `json:"outputs"`
	}{
		Copies:  1,
		Pattern: "greedy",
		Outputs: []interface{}{outConf},
	}

	conf := NewConfig()

	envConf := struct {
		HTTP     interface{} `json:"http"`
		Input    interface{} `json:"input"`
		Buffer   interface{} `json:"buffer"`
		Pipeline interface{} `json:"pipeline"`
		Output   interface{} `json:"output"`
		Logger   interface{} `json:"logger"`
		Metrics  interface{} `json:"metrics"`
	}{
		HTTP: conf.HTTP,
		Input: struct {
			Type   string      `json:"type"`
			Broker interface{} `json:"broker"`
		}{
			Type:   "broker",
			Broker: inBrokerConf,
		},
		Buffer:   conf.Buffer,
		Pipeline: pipeConf,
		Output: struct {
			Type   string      `json:"type"`
			Broker interface{} `json:"broker"`
		}{
			Type:   "broker",
			Broker: outBrokerConf,
		},
		Logger:  log.NewConfig(),
		Metrics: metrics.NewConfig(),
	}

	pathsMap := map[string]interface{}{}
	envConf.HTTP = envify("HTTP", envConf.HTTP, pathsMap)
	envConf.Input = envify("INPUT", envConf.Input, pathsMap)
	envConf.Buffer = envify("BUFFER", envConf.Buffer, pathsMap)
	envConf.Pipeline = envify("PIPELINE", envConf.Pipeline, pathsMap)
	envConf.Output = envify("OUTPUT", envConf.Output, pathsMap)
	envConf.Logger = envify("LOGGER", envConf.Logger, pathsMap)
	envConf.Metrics = envify("METRICS", envConf.Metrics, pathsMap)

	createYAML("environment file", filepath.Join(configsDir, "env", "default.yaml"), envConf)
	create("environment file docs", filepath.Join(configsDir, "env", "README.md"), formatEnvVars(pathsMap))
}

func main() {
	configsDir := "./config"
	flag.StringVar(&configsDir, "dir", configsDir, "The directory to write config examples")
	flag.Parse()

	// Get list of all types (both input and output).
	typeMap := map[string]struct{}{}
	for t := range input.Constructors {
		typeMap[t] = struct{}{}
	}
	for t := range output.Constructors {
		typeMap[t] = struct{}{}
	}

	// Generate configs for all types.
	for t := range typeMap {
		conf := NewConfig()
		conf.Input.Processors = nil
		conf.Output.Processors = nil
		conf.Pipeline.Processors = append(conf.Pipeline.Processors, processor.NewConfig())

		if _, exists := input.Constructors[t]; exists {
			conf.Input.Type = t
		}
		if _, exists := output.Constructors[t]; exists {
			conf.Output.Type = t
		}

		sanit, err := conf.Sanitised(true, true)
		if err != nil {
			panic(err)
		}

		createYAML(t, filepath.Join(configsDir, t+".yaml"), sanit)
		createJSON(t, filepath.Join(configsDir, t+".json"), sanit)
	}

	// Create processor configs for all types.
	for t := range processor.Constructors {
		conf := NewConfig()
		conf.Input.Processors = nil
		conf.Output.Processors = nil

		procConf := processor.NewConfig()
		procConf.Type = t

		conf.Pipeline.Processors = append(conf.Pipeline.Processors, procConf)

		sanit, err := conf.Sanitised(true, true)
		if err != nil {
			panic(err)
		}

		createYAML(t, filepath.Join(configsDir, "processors", t+".yaml"), sanit)
		createJSON(t, filepath.Join(configsDir, "processors", t+".json"), sanit)
	}

	// Create buffers config
	{
		t := "buffers"

		conf := NewConfig()
		conf.Input.Processors = nil
		conf.Output.Processors = nil

		sanit, err := conf.Sanitised(false, true)
		if err != nil {
			panic(err)
		}

		createYAML(t, filepath.Join(configsDir, t+".yaml"), sanit)
		createJSON(t, filepath.Join(configsDir, t+".json"), sanit)
	}

	// Create Environment Vars Config
	// createEnvConf(configsDir)
}

//------------------------------------------------------------------------------
